ifeq ($(ARCH), EIGEN)
# "Makefile" guard (like a C header guard).
# The current Makefile gets included from Makefile.gem5 as well (hacky
# solution), so don't pull in this one twice.
include common/Makefile.arch
endif

EIGEN_BINARY = $(BUILD_DIR)/nnet-eigen-native
EIGEN_BINARY_FOR_GEM5 = $(BUILD_DIR)/nnet-eigen-gem5

INCLUDES += -I$(SRC_DIR)/third_party/eigen
DLEVEL = 0

GEM5_SIMD_FLAGS = -msse
NATIVE_SIMD_FLAGS = -march=native

CFLAGS += -std=gnu++11 $(BMARK_SPECIFIC_CFLAGS) -O3 -flax-vector-conversions
CPPFLAGS += -DDMA_MODE -DEIGEN_ARCH_IMPL

EIGEN_ARCH_SRCS = $(SRC_DIR)/arch/eigen.cpp
EIGEN_FULL_PATH_CPP_SRCS = $(patsubst %.cpp, $(SRC_DIR)/%.cpp, $(EIGEN_SRCS))
NATIVE_FULL_PATH_SRCS += $(EIGEN_FULL_PATH_CPP_SRCS)

eigen-target: CFLAGS+=$(NATIVE_SIMD_FLAGS)
eigen-gem5: CFLAGS+=$(GEM5_SIMD_FLAGS) -static

eigen: eigen-target
eigen-target: $(EIGEN_BINARY)
eigen-gem5: $(EIGEN_BINARY_FOR_GEM5)

$(EIGEN_BINARY): $(NATIVE_FULL_PATH_SRCS) \
								 $(GEM5_FULL_PATH_SRCS) \
								 $(EIGEN_ARCH_SRCS)
	@echo Building benchmark $(EXEC) with Eigen backend for native host.
	@mkdir -p $(BUILD_DIR)
	@$(CXX) $(CPPFLAGS) $(CFLAGS) $^ -o $@ $(LFLAGS)

$(EIGEN_BINARY_FOR_GEM5): $(NATIVE_FULL_PATH_SRCS) \
													$(GEM5_FULL_PATH_SRCS) \
												 	$(EIGEN_ARCH_SRCS)
	@echo Building benchmark $(EXEC) with Eigen backend for gem5.
	@mkdir -p $(BUILD_DIR)
	@$(CXX) $(CPPFLAGS) $(CFLAGS) $^ -o $@ $(LFLAGS)

clean-eigen:
	rm -f $(EIGEN_BINARY)
	rm -f $(EIGEN_BINARY_FOR_GEM5)
